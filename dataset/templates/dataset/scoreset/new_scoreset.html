{% extends "dataset/base/base_create_update.html" %}


{% block form-action %}
  {% url 'dataset:scoreset_new' %}
{% endblock %}


{% block side-bar-title %}
  Create new score set
{% endblock %}


{% block side-bar-instructions %}
  Please fill out the form to the right. All fields will remain editable until published.
{% endblock %}


{% block top-instructions %}
  <p class="text-muted">
    Please fill our the form below. Not all fields are required, but filling
    in as much as your can is strongly recommended to encourage data completeness.
    You can always fill in the required fields now and then remaining fields
    at a later date. You can access the edit view for this submission
    from your <a href="{% url 'accounts:profile' %}">profile</a>
    once this form has been successfully submitted and processed.
  </p>
  <p class="text-muted">
    <b>Note: </b>You can only attach a score set to an <b>unpublished experiment</b> for which
    you have <b>edit</b> permissions on. Similarly, you can only replace
    score sets for which you have <b>edit</b> permission on, published or not.
  </p>
{% endblock %}


{% block form-block %}
  <div class="scoreset-form-group">
    <div class="scoreset-form">
      {% include 'core/bs_form.html' with form=scoreset_form %}
    </div>
  </div>
  <hr>

  <div class="target-gene-form-group">
    <h4>Target</h4>
    <p class="text-muted">
      Enter the name, type3 and reference sequence of your target. Alternatively,
      you can select an existing target from the drop-down menu below and
      auto fill the remaining form fields. The reference map section
      will be populated with the information associated with the primary reference
      for the selected target.
    </p>
    <div class="target-gene-form">
      {% include 'core/bs_form.html' with form=target_gene_form %}
    </div>
  </div>
  <hr>

  <div class="identifier-offset-form-group">
    <h4>Target identifiers</h4>
    <p class="text-muted">
      Associate an external identifier with your target. Select an existing
      identifier from the dropdown list or type in a new one and press enter.
    </p>
    <p class="text-muted">
      The reference offset is added to each position in the reference
      sequence to place it within the given target. Reference offset should be
      in amino acids for protein identifiers.
    </p>
  </div>
  <div id="sge-warning" class="alert alert-warning" role="alert" hidden></div>
  <div class="uniprot-offset-form-group">
    {% include 'core/bs_inline_form.html' with form=uniprot_offset_form %}
  </div>
  <div class="ensembl-offset-form-group">
    {% include 'core/bs_inline_form.html' with form=ensembl_offset_form %}
  </div>
  <div class="refseq-offset-form-group">
    {% include 'core/bs_inline_form.html' with form=refseq_offset_form %}
  </div>
  <hr>

  <div class="reference-map-form-group">
    <h4>
      Reference genome
    </h4>
    <p class="text-muted">
      Select an existing reference genome from the drop-down list. If you cannot find
      your particular reference in the list, please let us
      <a href="{% url 'main:contact' %}">know!</a>
    </p>
    <div class="reference-map-form">
      {% include 'core/bs_form.html' with form=reference_map_form %}
    </div>
  </div>
{% endblock %}


{% block extra_scripts %}
  <script type="text/javascript">
      $(document).ready(function () {
          init_select2();

          // ---------- Disable/enable experiment selection and meta-analysis selection
          // Run once on page load
          let select_element = $("#id_meta_analysis_for")
          maybe_toggle_experiment_input(select_element)

          $(select_element).on('change', function () {
              maybe_toggle_experiment_input(select_element);
          });

          function maybe_toggle_experiment_input(element) {
              if (element == null) return;

              let experiment_select = $("#id_experiment")
              if ($(element).val().length > 0) {
                  $(experiment_select).prop('disabled', true);
                  $(experiment_select).val('');
              } else {
                  $(experiment_select).prop('disabled', false);
              }
          }

          // -------------- Show warning when SGE dataset detected
          $("#id_score_data").change(function () {
              parse_file('#id_score_data');
          });

          $("#id_count_data").change(function () {
              parse_file('#id_count_data');
          });

          function warn_sge_missing_metadata(results, file) {
              if (
                  (has_tx_variants(results.data) || has_genomic_variants(results.data)) &&
                  metadata_is_empty()
              ) {
                  display_warnings();
              }
          }

          function has_tx_variants(data) {
              let tx_column_index = data[0].indexOf('hgvs_tx');
              if (tx_column_index < 0) return;

              let tx_variants = new Set()
              data.slice(1).forEach(function (row) {
                  if (row[tx_column_index] != null) {
                      tx_variants.add(row[tx_column_index]);
                  }
              });

              // Check if any tx variants are supplied. If not, return since we don't need to then do a
              // further check for metadata presence.
              let has_tx_variants = Array.from(tx_variants).some(function (variant) {
                  return variant.toString().startsWith('n.') || variant.toString().startsWith('c.')
              })

              if (tx_variants.size === 0 || !has_tx_variants) {
                  console.log('There are no transcript variants.');
                  return false;
              }
              return true;
          }

          function has_genomic_variants(data) {
              let nt_column_index = data[0].indexOf('hgvs_nt');
              if (nt_column_index < 0) return;

              let nt_variants = new Set()
              data.slice(1).forEach(function (row) {
                  if (row[nt_column_index] != null) {
                      nt_variants.add(row[nt_column_index]);
                  }
              });

              // Check if any g. variants are supplied. If not, return since we don't need to then do a
              // further check for metadata presence.
              let has_g_variants = Array.from(nt_variants).some(function (variant) {
                  return variant.toString().startsWith('g.')
              })

              if (nt_variants.size === 0 || !has_g_variants) {
                  console.log('There are no genomic variants.');
                  return false;
              }
              return true;
          }

          function metadata_is_empty() {
              let refseq = $("#id_refseq-offset-identifier").val();
              let uniprot = $("#id_uniprot-offset-identifier").val();
              let ensembl = $("#id_ensembl-offset-identifier").val();

              let refseq_blank = (refseq === "") || (refseq == null)
              let uniprot_blank = (uniprot === "") || (uniprot == null)
              let ensembl_blank = (ensembl === "") || (ensembl == null)

              return refseq_blank && uniprot_blank && ensembl_blank
          }

          function display_warnings() {
              $("#sge-warning")
                  .removeAttr('hidden')
                  .text(
                      'It looks like you are trying to upload an SGE dataset. We strongly encourage you to ' +
                      'provide the relevant sequence metadata.'
                  )
          }

          function parse_file(inputId) {
              $(inputId).parse({
                  config: {
                      complete: warn_sge_missing_metadata,
                      comments: '#',
                      skipEmptyLines: true,
                  },
                  error: function (err, file, inputElem, reason) {
                      console.log(err);
                      console.log(reason);
                      console.log(file);
                  },
              })
          }

          // ----------------------- Set replaces options when selecting experiments
          $("#id_experiment").on("change", function () {
              var id = this.value;
              var replaces_selector = "#id_replaces";
              var options = $(replaces_selector).children();

              $(replaces_selector)
                  .find('option')
                  .remove()
                  .end()
                  .append('<option value="">---------</option>')
                  .val("")
                  .trigger('change');

              if (parseInt(id)) {
                  $.ajax({
                      url: window.location.pathname,
                      type: "GET",
                      data: {"experiment": id},
                      dataType: "json",

                      success: function (data) {
                          // console.log(data);
                          $.each(options, function (index, option) {
                              if (option.value !== "") {
                                  $(option).remove();
                              } else {
                                  $(option).select();
                              }
                          });

                          $.each(data.scoresets, function (index, tuple) {
                              if (tuple[0] !== "" && tuple[1] !== "") {
                                  $(replaces_selector).append($("<option/>", {
                                      value: tuple[0],
                                      text: tuple[1] + ' | ' + tuple[2]
                                  }));
                              }
                          });
                      },
                      error: function (xhr, errmsg, err) {
                          console.log(xhr.status + ": " + xhr + errmsg + err);
                      }
                  })
              }
          });

          // ------------ Pre-fetch target information
          $("#id_target").on("change", function () {
              // First get whatever is in the form and send an ajax request
              // to convert it to markdown.
              if (window.location.href.includes('search')) {
                  return false;
              }

              var id = this.value;
              var uniprotSelect = $("#id_uniprot-offset-identifier");
              var uniprotOffsetElem = document.getElementById(
                  "id_uniprot-offset-offset");

              var refseqSelect = $("#id_refseq-offset-identifier");
              var refseqOffsetElem = document.getElementById(
                  "id_refseq-offset-offset");

              var ensemblSelect = $("#id_ensembl-offset-identifier");
              var ensemblOffsetElem = document.getElementById(
                  "id_ensembl-offset-offset");

              var nameElem = document.getElementById('id_name');
              var categoryElem = document.getElementById('id_category');
              var seqElem = document.getElementById('id_wt_sequence');
              var genomeSelect = $("#id_genome");

              if (parseInt(id)) {
                  $.ajax({
                      url: window.location.pathname,
                      type: "GET",
                      data: {"targetId": id},
                      dataType: "json",
                      success: function (data) {
                          console.log(data);
                          var targetName = data.name;
                          var wildTypeSequence = data.reference_sequence.sequence;
                          var category = data.type;
                          var referenceGenome = data.genome;

                          var uniprot_id, refseq_id, ensembl_id = null;
                          var uniprot_offset, refseq_offset, ensembl_offset = null;
                          if (data.uniprot != null) {
                              uniprot_id = data.uniprot.identifier;
                              uniprot_offset = data.uniprot.offset;
                          }
                          if (data.refseq != null) {
                              refseq_id = data.refseq.identifier;
                              refseq_offset = data.refseq.offset;
                          }
                          if (data.ensembl != null) {
                              ensembl_id = data.ensembl.identifier;
                              ensembl_offset = data.ensembl.offset;
                          }

                          // Change UniProt
                          if (uniprot_id) {
                              $(uniprotSelect).val(uniprot_id).trigger('change');
                              $(uniprotOffsetElem).val(uniprot_offset);
                          } else {
                              $(uniprotSelect).val("").trigger('change');
                              $(uniprotOffsetElem).val(0);
                          }

                          // Change RefSeq
                          if (refseq_id) {
                              $(refseqSelect).val(refseq_id).trigger('change');
                              $(refseqOffsetElem).val(refseq_offset);
                          } else {
                              $(refseqSelect).val("").trigger('change');
                              $(refseqOffsetElem).val(0);
                          }

                          // Change ensembl
                          if (ensembl_id) {
                              $(ensemblSelect).val(ensembl_id).trigger('change');
                              $(ensemblOffsetElem).val(ensembl_offset);
                          } else {
                              $(ensemblSelect).val("").trigger('change');
                              $(ensemblOffsetElem).val(0);
                          }

                          if (targetName) {
                              nameElem.value = targetName;
                          } else {
                              nameElem.value = "";
                          }
                          if (category) {
                              categoryElem.value = category;
                          } else {
                              categoryElem.value = "";
                          }
                          if (wildTypeSequence) {
                              seqElem.value = wildTypeSequence
                          } else {
                              seqElem.value = ""
                          }
                          if (referenceGenome) {
                              $(genomeSelect).val(referenceGenome).trigger('change');
                          } else {
                              $(genomeSelect).val("").trigger('change');
                          }
                      },
                      error: function (xhr, errmsg, err) {
                          console.log(xhr.status + ": " + xhr + errmsg + err);
                      }
                  });
                  return true;
              } else {
                  nameElem.value = "";
                  categoryElem.value = "";
                  seqElem.value = "";
                  $(genomeSelect).val("").trigger('change');

                  $(uniprotSelect).val("").trigger('change');
                  $(uniprotOffsetElem).val(0);

                  $(ensemblSelect).val("").trigger('change');
                  $(ensemblOffsetElem).val(0);

                  $(refseqSelect).val("").trigger('change');
                  $(refseqOffsetElem).val(0);
              }
              return false;
          });
      });
  </script>
{% endblock %}